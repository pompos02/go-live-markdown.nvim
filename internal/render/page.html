<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Go Live Markdown</title>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]],
        displayMath: [["$$", "$$"], ["\\[", "\\]"]]
      },
      options: {
        skipHtmlTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <style>
    /* Theme variables and design tokens. */
    :root {
      color-scheme: dark;
      --bg: #151515;
      --surface: #1a1a1a;
      --surface-2: #181818;
      --border: #333333;
      --text: #dddddd;
      --text-strong: #bbbbbb;
      --text-muted: #888888;
      --accent: #fd8000;
      --accent-soft: rgba(253, 128, 0, 0.18);
      --cursor-line-bg: rgba(253, 128, 0, 0.09);
      --table-head: #222222;
      --table-row: #1a1a1a;
      --table-row-alt: #1e1e1e;
      --task-bg: #1f1a14;
      --task-border: #4a3828;
      --task-done: #888888;
      --code-bg: #333333;
      --inline-bg: #333333;
      --alert-note: #4493f8;
      --alert-tip: #3fb950;
      --alert-important: #ab7df8;
      --alert-warning: #d29922;
      --alert-caution: #f85149;
      --syn-text: #e4e4ef;
      --syn-comment: #b17f3d;
      --syn-keyword: #ffdd33;
      --syn-string: #73c936;
      --syn-number: #f08d49;
      --syn-function: #96a6c8;
      --syn-constant: #9e95c7;
      --syn-variable: #ffffff;
      --syn-property: #cc8c3c;
      --syn-operator: #dddddd;
      --syn-punctuation: #aaaaaa;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 18px 14px 28px;
      color: var(--text);
      font-family:  "Berkeley Mono", "IosevkaCustom Nerd Font Mono", Inter,"Segoe UI Variable Text", "Segoe UI",  Consolas, "Fira Code", "IBM Plex Mono", "Cascadia Code", "JetBrains Mono", "SFMono-Regular", monospace;
      font-size: 15px;
      background: var(--bg);
    }

    .preview-header {
      max-width: 860px;
      margin: 0 auto;
      padding: 0 22px 8px;
      border-bottom: 1px solid var(--border);
    }

    .preview-filename {
      color: var(--text-muted);
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--alert-caution);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.35);
      flex: 0 0 auto;
    }

    .status-dot.is-connected {
      background: var(--alert-tip);
    }

    .md-root {
      max-width: 860px;
      min-height: 72vh;
      margin: 0 auto;
      padding: 20px 22px;
      line-height: 1.62;
      font-size: 0.95rem;
      overflow-anchor: none;
    }

    .md-root [data-md-line] {
      border-radius: 0 !important;
      position: relative;
      transition: box-shadow 90ms linear;
    }

    .md-root .is-cursor-line {
      background: var(--cursor-line-bg);
    }

    .md-root > :first-child {
      margin-top: 0;
    }

    .md-root > :last-child {
      margin-bottom: 0;
    }

    /* Base markdown element styling. */
    .md-root h1,
    .md-root h2,
    .md-root h3,
    .md-root h4,
    .md-root h5,
    .md-root h6 {
      color: var(--text-strong);
      line-height: 1.28;
      margin-top: 1.4em;
      margin-bottom: 0.4em;
      position: relative;
      padding-left: 1.1em;
      transition: color 120ms ease, text-decoration-color 120ms ease;
    }

    .md-root h1 {
      border-bottom: 1px solid var(--border);
      padding-bottom: 0.25em;
    }

    .md-root a {
      color: var(--accent);
      text-decoration: underline;
    }

    .md-root a[href^="wikilink:"],
    .md-root a[href^="wikilink:"]:visited,
    .md-root a[href^="wikilink:"]:hover,
    .md-root a[href^="wikilink:"]:focus-visible {
      color: #4a8dff;
      font-weight: 700;
      text-decoration: none;
      cursor: default;
    }

    .md-root h1 > a.anchor,
    .md-root h2 > a.anchor,
    .md-root h3 > a.anchor,
    .md-root h4 > a.anchor,
    .md-root h5 > a.anchor,
    .md-root h6 > a.anchor {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      margin: 0;
      text-decoration: none !important;
      transition: opacity 120ms ease;
    }

    .md-root h1:hover,
    .md-root h2:hover,
    .md-root h3:hover,
    .md-root h4:hover,
    .md-root h5:hover,
    .md-root h6:hover,
    .md-root h1:focus-within,
    .md-root h2:focus-within,
    .md-root h3:focus-within,
    .md-root h4:focus-within,
    .md-root h5:focus-within,
    .md-root h6:focus-within {
      color: var(--accent);
      text-decoration: underline;
      text-underline-offset: 0.12em;
      cursor: pointer;
    }

    .md-root h1:hover > a.anchor,
    .md-root h2:hover > a.anchor,
    .md-root h3:hover > a.anchor,
    .md-root h4:hover > a.anchor,
    .md-root h5:hover > a.anchor,
    .md-root h6:hover > a.anchor,
    .md-root h1:focus-within > a.anchor,
    .md-root h2:focus-within > a.anchor,
    .md-root h3:focus-within > a.anchor,
    .md-root h4:focus-within > a.anchor,
    .md-root h5:focus-within > a.anchor,
    .md-root h6:focus-within > a.anchor {
      opacity: 1;
    }

    .md-root p,
    .md-root ul,
    .md-root ol,
    .md-root table,
    .md-root blockquote,
    .md-root pre {
      margin-top: 0;
      margin-bottom: 1em;
    }

    .md-root img {
      display: block;
      max-width: 100%;
      height: auto;
      margin: 0.75em 0;
      border-radius: 4px;
    }

    .md-root blockquote {
      border-left: 2px solid var(--accent);
      margin: 0 0 1em;
      padding: 0 0 0 0.9em;
      color: #aaaaaa;
      border-radius: 0;
    }

    .md-root blockquote > :first-child {
      margin-top: 0;
    }

    .md-root blockquote > :last-child {
      margin-bottom: 0;
    }

    .md-root code,
    .md-root pre,
    .md-root .mono {
      font-family: "Berkeley Mono", "IosevkaCustom Nerd Font Mono", Consolas, "Fira Code", "IBM Plex Mono", "Cascadia Code", "JetBrains Mono", "SFMono-Regular", monospace;
    }

    .md-root :not(pre) > code {
      background: var(--inline-bg);
      color: #f7f7f7;
      padding: 0.15em 0.35em;
      border-radius: 6px;
      border: none;
    }

    .md-root pre {
      position: relative;
      border: 1px solid #000000;
      background: var(--code-bg);
      border-radius: 4px;
      padding: 24px 14px 12px;
      overflow-x: auto;
    }

    .md-root pre[data-lang]::before {
      content: attr(data-lang);
      position: absolute;
      top: 6px;
      right: 10px;
      font-size: 0.68rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .md-root pre code {
      color: #e4e4ef;
      padding: 0;
      background: transparent;
      border: 0;
    }

    .md-root .chroma,
    .md-root pre.chroma,
    .md-root pre[style] {
      background: var(--code-bg) !important;
      color: #e4e4ef;
    }

    .md-root .chroma .bg {
      background: transparent !important;
    }

    .md-root pre code,
    .md-root pre code span {
      color: var(--syn-text);
    }

    /* Chroma/highlight token color mapping. */
    .md-root .tok-comment,
    .md-root .chroma .c,
    .md-root .chroma .c1,
    .md-root .chroma .cm,
    .md-root .token.comment,
    .md-root .hljs-comment {
      color: var(--syn-comment);
    }

    .md-root .tok-keyword,
    .md-root .chroma .k,
    .md-root .chroma .kd,
    .md-root .chroma .kn,
    .md-root .chroma .kp,
    .md-root .chroma .kr,
    .md-root .token.keyword,
    .md-root .hljs-keyword,
    .md-root .hljs-selector-tag {
      color: var(--syn-keyword);
      font-weight: 600;
    }

    .md-root .tok-string,
    .md-root .chroma .s,
    .md-root .chroma .s1,
    .md-root .chroma .s2,
    .md-root .chroma .sa,
    .md-root .chroma .sb,
    .md-root .token.string,
    .md-root .hljs-string,
    .md-root .hljs-attribute {
      color: var(--syn-string);
    }

    .md-root .tok-number,
    .md-root .chroma .m,
    .md-root .chroma .mi,
    .md-root .chroma .mf,
    .md-root .token.number,
    .md-root .hljs-number,
    .md-root .hljs-literal {
      color: var(--syn-number);
    }

    .md-root .tok-function,
    .md-root .chroma .nf,
    .md-root .chroma .fm,
    .md-root .token.function,
    .md-root .hljs-function,
    .md-root .hljs-title.function_ {
      color: var(--syn-function);
    }

    .md-root .tok-constant,
    .md-root .chroma .kc,
    .md-root .chroma .kt,
    .md-root .chroma .nc,
    .md-root .token.constant,
    .md-root .token.class-name,
    .md-root .hljs-type,
    .md-root .hljs-built_in {
      color: var(--syn-constant);
    }

    .md-root .tok-variable,
    .md-root .chroma .nv,
    .md-root .chroma .vc,
    .md-root .token.variable,
    .md-root .hljs-variable,
    .md-root .hljs-params {
      color: var(--syn-variable);
    }

    .md-root .tok-property,
    .md-root .chroma .na,
    .md-root .token.property,
    .md-root .hljs-property,
    .md-root .hljs-attr {
      color: var(--syn-property);
    }

    .md-root .tok-operator,
    .md-root .chroma .o,
    .md-root .token.operator,
    .md-root .hljs-operator {
      color: var(--syn-operator);
    }

    .md-root .tok-punctuation,
    .md-root .chroma .p,
    .md-root .token.punctuation {
      color: var(--syn-punctuation);
    }

    /* Table styling tuned for dense technical docs. */
    .md-root table {
      border-collapse: separate;
      border-spacing: 0;
      width: 100%;
      background: linear-gradient(180deg, #1a1a1a 0%, #1e1e1e 100%);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.32);
    }

    .md-root td,
    .md-root th {
      border-right: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      padding: 8px 10px;
    }

    .md-root th {
      background: var(--table-head);
      color: var(--text-strong);
      text-align: left;
      letter-spacing: 0.02em;
      font-weight: 700;
      text-decoration: underline;
    }

    .md-root td {
      background: var(--table-row);
    }

    .md-root tr:nth-child(even) td {
      background: var(--table-row-alt);
    }

    .md-root tr:hover td {
      background: #252525;
    }

    .md-root tr > :last-child {
      border-right: 0;
    }

    .md-root table tr:last-child > * {
      border-bottom: 0;
    }

    .md-root hr {
      border: 0;
      border-top: 1px solid #444444;
    }

    /* Task list checkboxes and completed-item visuals. */
    .md-root input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 15px;
      height: 15px;
      border: 1.5px solid var(--text-muted);
      border-radius: 4px;
      background: var(--bg);
      vertical-align: middle;
      margin-right: 8px;
      cursor: default;
      position: relative;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }

    .md-root input[type="checkbox"]:checked {
      background: var(--accent);
      border-color: var(--accent);
    }

    .md-root input[type="checkbox"]:checked::after {
      content: "";
      position: absolute;
      left: 4px;
      top: 1px;
      width: 4px;
      height: 8px;
      border: solid var(--bg);
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    .md-root ul,
    .md-root ol {
      padding-left: 1.2em;
    }

    .md-root li {
      margin: 0.26em 0;
    }

    .md-root li.task-list-item,
    .md-root ul.contains-task-list > li {
      list-style: none;
      margin-left: -0.5em;
      padding: 0.32em 0.55em 0.35em 0.45em;
      border: 1px solid var(--task-border);
      border-radius: 6px;
      background: linear-gradient(180deg, var(--task-bg), #1a1510);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.32);
    }

    .md-root li.task-list-item + li.task-list-item,
    .md-root ul.contains-task-list > li + li {
      margin-top: 0.42em;
    }

    .md-root li.task-list-item:has(> input[type="checkbox"]:checked),
    .md-root ul.contains-task-list > li:has(> input[type="checkbox"]:checked) {
      border-color: #6a5038;
      background: linear-gradient(180deg, rgba(80, 60, 40, 0.9), var(--accent-soft));
      color: var(--task-done);
    }

    /* Alert/callout blocks from markdown extensions. */
    .md-root .markdown-alert {
      padding: 0.5em 1em 0.7em;
      color: var(--text);
      border-left-width: 0.25em;
      border-left-style: solid;
      margin-bottom: 1em;
    }

    .md-root .markdown-alert > :first-child {
      margin-top: 0;
    }

    .md-root .markdown-alert > :last-child {
      margin-bottom: 0;
    }

    .md-root .markdown-alert .markdown-alert-title {
      display: flex;
      align-items: center;
      gap: 0.5em;
      margin-bottom: 0.55em;
      font-weight: 600;
      line-height: 1;
    }

    .md-root .markdown-alert .markdown-alert-icon {
      width: 1em;
      height: 1em;
      fill: currentColor;
      flex: 0 0 auto;
    }

    .md-root .markdown-alert.markdown-alert-note {
      border-left-color: var(--alert-note);
    }

    .md-root .markdown-alert.markdown-alert-note .markdown-alert-title {
      color: var(--alert-note);
    }

    .md-root .markdown-alert.markdown-alert-tip {
      border-left-color: var(--alert-tip);
    }

    .md-root .markdown-alert.markdown-alert-tip .markdown-alert-title {
      color: var(--alert-tip);
    }

    .md-root .markdown-alert.markdown-alert-important {
      border-left-color: var(--alert-important);
    }

    .md-root .markdown-alert.markdown-alert-important .markdown-alert-title {
      color: var(--alert-important);
    }

    .md-root .markdown-alert.markdown-alert-warning {
      border-left-color: var(--alert-warning);
    }

    .md-root .markdown-alert.markdown-alert-warning .markdown-alert-title {
      color: var(--alert-warning);
    }

    .md-root .markdown-alert.markdown-alert-caution {
      border-left-color: var(--alert-caution);
    }

    .md-root .markdown-alert.markdown-alert-caution .markdown-alert-title {
      color: var(--alert-caution);
    }

    .md-root .callout-title,
    .md-root .callout-body {
      margin: 0;
      padding-left: 1rem;
      border-left: 0.25em solid var(--border);
    }

    .md-root .callout-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0;
      padding-bottom: 0;
      color: var(--alert-note);
      font-weight: 600;
      line-height: 1;
    }

    .md-root .callout-title + .callout-body {
      padding-top: 0.8rem;
      padding-bottom: 0.3rem;
      margin-bottom: 16px;
    }

    .md-root .callout-title svg {
      width: 1rem;
      height: 1rem;
      flex: 0 0 auto;
    }

    .md-root .callout-title-text {
      margin: 0;
      font-size: 0.875rem;
      font-weight: 600;
      line-height: 1;
    }

    .md-root .callout-body {
      color: var(--text);
    }

    .md-root .callout-body > :first-child {
      margin-top: 0;
    }

    .md-root .callout-body > :last-child {
      margin-bottom: 0;
    }

    .md-root .callout-title:has(.lucide-info-icon),
    .md-root .callout-title:has(.lucide-info-icon) + .callout-body {
      border-left-color: var(--alert-note);
    }

    .md-root .callout-title:has(.lucide-info-icon) {
      color: var(--alert-note);
    }

    .md-root .callout-title:has(.lucide-lightbulb-icon),
    .md-root .callout-title:has(.lucide-lightbulb-icon) + .callout-body {
      border-left-color: var(--alert-tip);
    }

    .md-root .callout-title:has(.lucide-lightbulb-icon) {
      color: var(--alert-tip);
    }

    .md-root .callout-title:has(.lucide-message-square-icon),
    .md-root .callout-title:has(.lucide-message-square-warning-icon),
    .md-root .callout-title:has(.lucide-message-circle-warning-icon),
    .md-root .callout-title:has([class*="message-square"]),
    .md-root .callout-title:has([class*="message-circle"]),
    .md-root .callout-title:has(.lucide-message-square-icon) + .callout-body,
    .md-root .callout-title:has(.lucide-message-square-warning-icon) + .callout-body,
    .md-root .callout-title:has(.lucide-message-circle-warning-icon) + .callout-body,
    .md-root .callout-title:has([class*="message-square"]) + .callout-body,
    .md-root .callout-title:has([class*="message-circle"]) + .callout-body {
      border-left-color: var(--alert-important);
    }

    .md-root .callout-title:has(.lucide-message-square-icon),
    .md-root .callout-title:has(.lucide-message-square-warning-icon),
    .md-root .callout-title:has(.lucide-message-circle-warning-icon),
    .md-root .callout-title:has([class*="message-square"]),
    .md-root .callout-title:has([class*="message-circle"]) {
      color: var(--alert-important);
    }

    .md-root .callout-title:has(.lucide-triangle-alert-icon),
    .md-root .callout-title:has(.lucide-triangle-alert-icon) + .callout-body {
      border-left-color: var(--alert-warning);
    }

    .md-root .callout-title:has(.lucide-triangle-alert-icon) {
      color: var(--alert-warning);
    }

    .md-root .callout-title:has(.lucide-octagon-alert-icon),
    .md-root .callout-title:has(.lucide-octagon-alert-icon) + .callout-body {
      border-left-color: var(--alert-caution);
    }

    .md-root .callout-title:has(.lucide-octagon-alert-icon) {
      color: var(--alert-caution);
    }

    @media (max-width: 900px) {
      body {
        padding: 10px;
      }

      .preview-header {
        padding: 0 14px 8px;
      }

      .md-root {
        padding: 16px 14px;
        min-height: calc(100vh - 80px);
      }
    }
  </style>
</head>
<body>
  <header class="preview-header">
    <div class="preview-filename">
      <span class="status-dot" id="preview-conn-indicator" aria-label="disconnected"></span>
      <span id="preview-filename">[No Name]</span>
    </div>
  </header>
  <article class="md-root">{{CONTENT}}</article>

  <script>
    (function () {
      // DOM anchors and connection state.
      var root = document.querySelector(".md-root");
      var filenameEl = document.getElementById("preview-filename");
      var connectionIndicatorEl = document.getElementById("preview-conn-indicator");
      if (!root) return;

      var socket = null;
      var retryTimer = null;
      var latestRev = 0;
      var lineMap = [];
      var activeLineEl = null;
      var lastCursorLine = null;
      var followTargetTop = null;
      var followRaf = 0;
      var followLastTs = 0;
      var manualScrollCooldownUntil = 0;
      var currentFilename = "[No Name]";
      var isConnected = false;
      var headingClickTimer = 0;

      // Auto-follow tuning constants.
      var MANUAL_SCROLL_COOLDOWN_MS = 220;
      var HEADING_CLICK_DELAY_MS = 240;
      var HEADING_NAV_COOLDOWN_MS = 900;
      var FOLLOW_SNAP_DISTANCE_PX = 0.6;
      var COMFORT_TOP = 0.30;
      var COMFORT_BOTTOM = 0.30;
      var FOLLOW_RATIO = Math.max(0.05, Math.min(0.95, (COMFORT_TOP + COMFORT_BOTTOM) / 2));

      function updateTitle() {
        document.title = (isConnected ? "" : "! ") + currentFilename;
      }

      function setConnectionState(connected) {
        isConnected = !!connected;
        if (connectionIndicatorEl) {
          connectionIndicatorEl.classList.toggle("is-connected", !!connected);
          connectionIndicatorEl.setAttribute("aria-label", connected ? "connected" : "disconnected");
        }
        updateTitle();
      }

      function toInt(value, fallback) {
        var n = Number(value);
        return Number.isFinite(n) ? n : fallback;
      }

      function typesetMath(rootEl) {
        if (!rootEl) return;
        if (!window.MathJax || typeof window.MathJax.typesetPromise !== "function") {
          return;
        }

        if (typeof window.MathJax.typesetClear === "function") {
          window.MathJax.typesetClear([rootEl]);
        }

        window.MathJax.typesetPromise([rootEl]).catch(function () {});
      }

      function syncCodeBlockLanguages(rootEl) {
        if (!rootEl) return;

        var wrappers = rootEl.querySelectorAll("[data-lang]");
        for (var i = 0; i < wrappers.length; i++) {
          var wrapper = wrappers[i];
          var lang = wrapper.getAttribute("data-lang");
          if (!lang) continue;

          var pre = wrapper.querySelector("pre");
          if (!pre) continue;

          pre.setAttribute("data-lang", lang);
        }
      }

      // Build a sorted index of rendered elements by source markdown line.
      function buildLineMap() {
        var candidates = root.querySelectorAll("[data-md-line]");
        var out = [];

        for (var i = 0; i < candidates.length; i++) {
          var el = candidates[i];
          var line = toInt(el.getAttribute("data-md-line"), NaN);
          if (!Number.isFinite(line)) continue;

          out.push({
            line: line,
            el: el,
            order: i,
          });
        }

        out.sort(function (a, b) {
          if (a.line === b.line) return a.order - b.order;
          return a.line - b.line;
        });

        lineMap = out;
      }

      function maxScrollTop() {
        var doc = document.documentElement;
        return Math.max(0, doc.scrollHeight - window.innerHeight);
      }

      function getScrollTop() {
        return window.scrollY || document.documentElement.scrollTop || 0;
      }

      function clampScrollTop(top) {
        var clamped = Number(top);
        if (!Number.isFinite(clamped)) return window.scrollY || 0;
        if (clamped < 0) return 0;
        var maxTop = maxScrollTop();
        if (clamped > maxTop) return maxTop;
        return clamped;
      }

      function stopFollowAnimation() {
        if (followRaf) {
          cancelAnimationFrame(followRaf);
          followRaf = 0;
        }
        followLastTs = 0;
      }

      function suppressAutoFollow(ms) {
        var cooldown = Number(ms);
        if (!Number.isFinite(cooldown)) {
          cooldown = MANUAL_SCROLL_COOLDOWN_MS;
        }
        cooldown = Math.max(MANUAL_SCROLL_COOLDOWN_MS, cooldown);
        manualScrollCooldownUntil = performance.now() + cooldown;
        followTargetTop = getScrollTop();
        stopFollowAnimation();
      }

      function markManualScrollIntent() {
        suppressAutoFollow(MANUAL_SCROLL_COOLDOWN_MS);
      }

      function isScrollKey(event) {
        var key = event && event.key;
        return (
          key === "ArrowUp" ||
          key === "ArrowDown" ||
          key === "PageUp" ||
          key === "PageDown" ||
          key === "Home" ||
          key === "End" ||
          key === " " ||
          key === "Spacebar"
        );
      }

      // Smooth follow animation for cursor tracking.
      function stepFollow(ts) {
        if (followTargetTop === null) {
          stopFollowAnimation();
          return;
        }

        if (followLastTs === 0) {
          followLastTs = ts;
        }

        var dt = Math.max(1 / 120, Math.min(1 / 20, (ts - followLastTs) / 1000));
        followLastTs = ts;

        var targetTop = clampScrollTop(followTargetTop);
        var currentTop = getScrollTop();
        var distance = targetTop - currentTop;

        if (Math.abs(distance) < FOLLOW_SNAP_DISTANCE_PX) {
          window.scrollTo({ top: targetTop, behavior: "auto" });
          stopFollowAnimation();
          return;
        }

        var distanceAbs = Math.abs(distance);
        var t = Math.min(1, distanceAbs / 1200);
        var responsiveness = 8 + 10 * t;
        var maxSpeed = 22200 + 7800 * t * t;

        var alpha = 1 - Math.exp(-responsiveness * dt);
        var unclampedStep = distance * alpha;
        var maxStep = maxSpeed * dt;
        var step = Math.max(-maxStep, Math.min(maxStep, unclampedStep));
        var nextTop = clampScrollTop(currentTop + step);

        window.scrollTo({ top: nextTop, behavior: "auto" });
        followRaf = requestAnimationFrame(stepFollow);
      }

      function animateToScrollTop(top, force) {
        var clampedTop = clampScrollTop(top);

        if (force) {
          followTargetTop = clampedTop;
          stopFollowAnimation();
          window.scrollTo({ top: clampedTop, behavior: "auto" });
          return;
        }

        followTargetTop = clampedTop;
        if (followRaf === 0) {
          followRaf = requestAnimationFrame(stepFollow);
        }
      }

      function targetTopForElement(target) {
        var viewport = window.innerHeight || document.documentElement.clientHeight;
        var absoluteTop = getScrollTop() + target.getBoundingClientRect().top;
        return absoluteTop - viewport * FOLLOW_RATIO;
      }

      function targetTopByLineRatio(line) {
        if (lineMap.length === 0) {
          return getScrollTop();
        }

        var maxLine = Math.max(lineMap[lineMap.length - 1].line, 1);
        var ratio = Math.max(0, Math.min(1, line / maxLine));
        return maxScrollTop() * ratio;
      }

      // Keep the active line in a comfort zone rather than hard-centering.
      function outsideComfortZone(targetEl) {
        if (!targetEl) return true;

        var viewport = window.innerHeight || document.documentElement.clientHeight;
        var comfortTopPx = viewport * COMFORT_TOP;
        var comfortBottomPx = viewport * (1 - COMFORT_BOTTOM);
        var rect = targetEl.getBoundingClientRect();

        return rect.top < comfortTopPx || rect.bottom > comfortBottomPx;
      }

      // Binary search for the nearest mapped line not after the requested line.
      function pickTarget(line) {
        if (lineMap.length === 0) return null;

        if (line <= lineMap[0].line) return lineMap[0];
        var last = lineMap[lineMap.length - 1];
        if (line >= last.line) return last;

        var left = 0;
        var right = lineMap.length - 1;
        var candidate = lineMap[0];

        while (left <= right) {
          var mid = (left + right) >> 1;
          var cur = lineMap[mid];

          if (cur.line <= line) {
            candidate = cur;
            left = mid + 1;
            continue;
          }

          right = mid - 1;
        }

        return candidate;
      }

      function setActiveLine(nextEl) {
        if (activeLineEl === nextEl) return;

        if (activeLineEl) {
          activeLineEl.classList.remove("is-cursor-line");
        }

        activeLineEl = nextEl || null;
        if (activeLineEl) {
          activeLineEl.classList.add("is-cursor-line");
        }
      }

      function highlightLine(line) {
        var target = pickTarget(line);
        if (!target || !target.el) {
          setActiveLine(null);
          return null;
        }

        setActiveLine(target.el);
        return target;
      }

      function scrollToLine(line, force) {
        var target = highlightLine(line);
        if (!force && performance.now() < manualScrollCooldownUntil) {
          return;
        }

        if (!force && target && target.el && !outsideComfortZone(target.el)) {
          return;
        }

        var top;
        if (!target || !target.el) {
          top = targetTopByLineRatio(line);
        } else {
          top = targetTopForElement(target.el);
        }

        animateToScrollTop(top, !!force);
      }

      // WebSocket lifecycle: connect, reconcile revisions, and retry on close.
      function connect() {
        var proto = window.location.protocol === "https:" ? "wss:" : "ws:";
        var url = proto + "//" + window.location.host + "/ws";
        socket = new WebSocket(url);

        socket.onopen = function () {
          setConnectionState(true);
        };

        socket.onmessage = function (event) {
          var msg;
          try {
            msg = JSON.parse(event.data);
          } catch (_) {
            return;
          }

          if (msg.type === "render") {
            stopFollowAnimation();
            followTargetTop = null;
            setActiveLine(null);
            root.innerHTML = typeof msg.html === "string" ? msg.html : "";
            currentFilename = typeof msg.filename === "string" ? msg.filename.trim() : "";
            if (!currentFilename) {
              currentFilename = "[No Name]";
            }
            if (filenameEl) {
              filenameEl.textContent = currentFilename;
            }
            updateTitle();
            latestRev = toInt(msg.rev, latestRev);
            buildLineMap();
            syncCodeBlockLanguages(root);
            typesetMath(root);

            if (lastCursorLine !== null) {
              highlightLine(lastCursorLine);
            }
            return;
          }

          if (msg.type === "cursor") {
            var rev = toInt(msg.rev, 0);
            if (rev !== latestRev) return;

            var line = toInt(msg.line, 1);
            if (lastCursorLine !== null && lastCursorLine === line) return;

            lastCursorLine = line;
            scrollToLine(line, false);
          }
        };

        socket.onerror = function () {
          setConnectionState(false);
          socket.close();
        };

        socket.onclose = function () {
          setConnectionState(false);
          if (retryTimer) clearTimeout(retryTimer);
          retryTimer = setTimeout(connect, 500);
        };
      }

      function isInteractiveTarget(el) {
        if (!el || !(el instanceof Element)) return false;
        if (el.closest("a[href], button, input, textarea, select, summary")) {
          return true;
        }
        return false;
      }

      function isWikilinkAnchor(el) {
        if (!el || !(el instanceof Element)) return false;
        var anchor = el.closest('a[href^="wikilink:"]');
        return anchor instanceof HTMLAnchorElement;
      }

      function handleWikilinkClick(event) {
        if (!event || event.defaultPrevented) return;

        var target = event.target;
        if (target && target.nodeType === Node.TEXT_NODE) {
          target = target.parentElement;
        }

        if (!isWikilinkAnchor(target)) return;

        event.preventDefault();
      }

      function pickLineElementFromEvent(event) {
        if (!event) return null;

        var target = event.target;
        if (target && target.nodeType === Node.TEXT_NODE) {
          target = target.parentElement;
        }

        if (!(target instanceof Element)) return null;

        var lineEl = target.closest("[data-md-line]");
        if (lineEl) return lineEl;

        var fromPoint = document.elementFromPoint(event.clientX, event.clientY);
        if (!(fromPoint instanceof Element)) return null;
        return fromPoint.closest("[data-md-line]");
      }

      function sendGoToLine(line) {
        if (!Number.isFinite(line) || line < 1) return;
        if (!socket || socket.readyState !== WebSocket.OPEN) return;

        socket.send(
          JSON.stringify({
            type: "go_to_line",
            line: line,
            col: 1,
            rev: latestRev,
          })
        );
      }

      function pickHeadingFromEvent(event) {
        if (!event) return null;

        var target = event.target;
        if (target && target.nodeType === Node.TEXT_NODE) {
          target = target.parentElement;
        }

        if (!(target instanceof Element)) return null;
        var heading = target.closest("h1, h2, h3, h4, h5, h6");
        if (!(heading instanceof HTMLElement)) return null;
        return heading;
      }

      function clearHeadingClickTimer() {
        if (!headingClickTimer) return;
        clearTimeout(headingClickTimer);
        headingClickTimer = 0;
      }

      function headingTextHit(heading, event) {
        if (!heading || !event || !document.createRange) return false;

        var range = document.createRange();
        range.selectNodeContents(heading);
        var rects = range.getClientRects();
        if (!rects || rects.length === 0) return false;

        var x = event.clientX;
        var y = event.clientY;
        for (var i = 0; i < rects.length; i++) {
          var rect = rects[i];
          if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
            return true;
          }
        }

        return false;
      }

      function navigateToHeadingAnchor(heading) {
        if (!heading) return;

        var anchorEl = heading.querySelector("a.anchor[href^='#']");
        var href = anchorEl ? anchorEl.getAttribute("href") : "";
        if (!href && heading.id) {
          href = "#" + heading.id;
        }
        if (!href || href.charAt(0) !== "#") return;

        suppressAutoFollow(HEADING_NAV_COOLDOWN_MS);

        if (window.location.hash !== href) {
          window.location.hash = href;
          setTimeout(function () {
            suppressAutoFollow(HEADING_NAV_COOLDOWN_MS);
          }, 0);
          return;
        }

        if (heading.scrollIntoView) {
          heading.scrollIntoView({ block: "start", behavior: "auto" });
        }
        suppressAutoFollow(HEADING_NAV_COOLDOWN_MS);
      }

      // Single-clicking a heading navigates to that heading anchor.
      function handleHeadingClick(event) {
        if (!event || event.defaultPrevented) return;
        if (event.button !== 0) return;
        if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;

        var heading = pickHeadingFromEvent(event);
        if (!heading) return;
        if (!headingTextHit(heading, event)) return;
        if (event.detail > 1) return;

        event.preventDefault();
        clearHeadingClickTimer();
        headingClickTimer = setTimeout(function () {
          headingClickTimer = 0;
          navigateToHeadingAnchor(heading);
        }, HEADING_CLICK_DELAY_MS);
      }

      // Double-click in preview requests an editor cursor jump.
      function handlePreviewDoubleClick(event) {
        clearHeadingClickTimer();
        if (!event || event.defaultPrevented) return;
        if (event.button !== 0) return;
        if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;

        var targetEl = event.target;
        if (targetEl && targetEl.nodeType === Node.TEXT_NODE) {
          targetEl = targetEl.parentElement;
        }

        if (isInteractiveTarget(targetEl)) {
          return;
        }

        var lineEl = pickLineElementFromEvent(event);
        if (!lineEl) return;

        var line = toInt(lineEl.getAttribute("data-md-line"), NaN);
        if (!Number.isFinite(line) || line < 1) return;

        sendGoToLine(line);
      }

      window.addEventListener("wheel", markManualScrollIntent, { passive: true });
      window.addEventListener("touchstart", markManualScrollIntent, { passive: true });
      window.addEventListener("touchmove", markManualScrollIntent, { passive: true });
      window.addEventListener("keydown", function (event) {
        if (isScrollKey(event)) {
          markManualScrollIntent();
        }
      });
      root.addEventListener("click", handleWikilinkClick);
      root.addEventListener("auxclick", handleWikilinkClick);
      root.addEventListener("click", handleHeadingClick);
      root.addEventListener("dblclick", handlePreviewDoubleClick);

      updateTitle();
      connect();
    })();
  </script>
</body>
</html>
